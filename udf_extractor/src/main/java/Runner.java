import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

public class Runner extends Logging {

    public static void main(String[] args) throws Exception {

        // Set this for now
        //Todo: In case of complete dataflow program this class file path will automatically generated by the tool using just the Spark App.
        String classfile = "/Users/malig/workspace/git/Test-Minimization-in-Big-Data/udf_extractor/target/scala-2.11/classes/Test3$";
        String conf_file = "/Users/malig/workspace/git/Test-Minimization-in-Big-Data/udf_extractor/src/main/scala/Test3.conf";
        // Input arguments to the UDFS  (UDF-name --> input args) .
        // Required for SPF. The Ids appended to the operator name are in reverse order.
        // Write the input args in the <classname>.conf file

        readSPFInputArgs(conf_file);

        /* Manually inserting input args
        Configuration.map_args.put("filter1" , "1");
        Configuration.map_args.put("map2" , "2");
        Configuration.map_args.put("map3" , "\"3\"");
        */

        String outputJava = Configuration.JPF_HOME+ "jpf-symbc/src/examples/spf/";
        createDirectory(outputJava);
        String jpfJar = Configuration.JPF_HOME+ "jpf-core/build/RunJPF.jar";
        String classname = classfile.split("/")[classfile.split("/").length - 1];
        String classFile_jad = classname + ".jad";
        String jpfModel = Configuration.JPF_HOME+ "jpf-symbc/src/examples/spf/";//+fixClassName(classname)+".jpf";


        // Decompile and extract the UDF
        // Compiling the newly extracted UDF
        UDFDecompilerAndExtractor udf_ex = new UDFDecompilerAndExtractor(classfile, classFile_jad, outputJava );
        udf_ex.ParseFilesInDir(jpfModel);
        for(JPFDAGNode j :     udf_ex.jpf_dag){
            // Run JPF on the UDF
             runCommand(new String[]{"java", "-jar", jpfJar, j.jpf_file}, Configuration.JAVA_RUN_DIR);

        }


 }
public static void readSPFInputArgs(String classname){
    try(BufferedReader br = new BufferedReader(new FileReader(classname ))) {
        for(String line; (line = br.readLine()) != null; ) {
           String arr[] = line.split(">");
            if(arr.length !=2){
                logerr("Invalid Configuration File");
                return;
            }else{
                Configuration.map_args.put(arr[0].trim(), arr[1].trim());
                logdebug("Adding input arguments : " + arr[0].trim() + " --> "+ arr[1].trim());
            }
        }
        // line is not visible here.
    }catch(Exception e){
        e.printStackTrace();
    }


    }
    public static void createDirectory(String dir){
        File file = new File(dir);
        if(!file.exists()){
            loginfo(LogType.INFO, "Output directory does not exist: Creating one ...");
            file.mkdirs();
        }else{
            loginfo(LogType.INFO, "Output directory already exist");
        }
    }
    public static void runCommand(String[] args, String dir) {
// build the system command we want to run
        String s = "";
        for (String a : args) {
            s = s + "  " + a;
        }
         loginfo(LogType.INFO , "Running Command : " + s )  ;

        try {
            List<String> commands = new ArrayList<String>();
            commands.add("/bin/sh");
            commands.add("-c");
            commands.add(s);
            //commands.add("echo $JAVA_HOME");

            // execute the command
            SystemCommandExecutor commandExecutor = new SystemCommandExecutor(commands, dir);
            int result = commandExecutor.executeCommand();

            // get the stdout and stderr from the command that was run
            StringBuilder stdout = commandExecutor.getStandardOutputFromCommand();
            StringBuilder stderr = commandExecutor.getStandardErrorFromCommand();

            // print the stdout and stderr
            loginfo(LogType.INFO , stdout.toString());
            loginfo(LogType.WARN , stderr.toString());
 } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static String fixClassName(String s){
       return  s.replace("$" , "");
    }
}

